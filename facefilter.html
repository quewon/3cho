<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
    <meta charset="utf-8">
    <title></title>
    <style media="screen">
      body, html {
        margin: 0;
        overflow: hidden;
        background: black;
      }
      canvas, video {
        position: absolute;
        top: 50%;
        left: 50%;
        translate: -50% -50%;
        scale: -1 1;
      }

      #test, video {
        display: none;
      }
    </style>
  </head>
  <body>

    <video onloadedmetadata="resizeVideo(); updateLandmarks()" autoplay muted playsinline></video>

    <canvas id="main"></canvas>

    <canvas id="test"></canvas>

  </body>

  <script type="text/javascript" src="js/lib/face-api.js"></script>
  <script type="text/javascript" src="js/lib/facefunctions.js"></script>
  <script type="text/javascript">
    var canvas = document.getElementById("main");
    var context = canvas.getContext("2d");
    var testcanvas = document.getElementById("test");
    var testcontext = testcanvas.getContext("2d");
    var video = document.querySelector("video");
    var dims;

    window.onresize = function() {
      resizeVideo();
    }

    function resizeVideo() {
      var vw = video.videoWidth;
      var vh = video.videoHeight;
      var ww = window.innerWidth;
      var wh = window.innerHeight;

      var scale = wh/vh;
      if (ww >= wh && ww >= vw*scale) {
      } else {
        scale = ww/vw;
      }
      video.style.scale = (-scale)+" "+scale;

      dims = faceapi.matchDimensions(canvas, video, true);
      canvas.width *= window.devicePixelRatio;
      canvas.height *= window.devicePixelRatio;
      canvas.style.scale = (-scale/window.devicePixelRatio)+" "+scale/window.devicePixelRatio;
    }

    window.onload = async function() {
      const stream = await navigator.mediaDevices.getUserMedia({ video: true });
      video.srcObject = stream;
      await video.play();

      await initFaceDetection();

      draw();
    }

    var players = [];
    var positions = [
      {
        leftEye: { x:100, y:100 },
        rightEye: { x:200, y:100 },
        mouth: { x:150, y:200 },
        nose: { x:150, y:150 },
      }
    ];

    async function updateLandmarks() {
      if (video.paused || video.ended || !isFaceDetectionModelLoaded())
        return setTimeout(updateLandmarks);

      const options = getFaceDetectorOptions();
      const results = await faceapi.detectAllFaces(video, options).withFaceLandmarks()

      if (results.length > 0) {
        for (let i=0; i<results.length; i++) {
          const landmarks = faceapi.resizeResults(results[i], dims).landmarks;

          if (!players[i]) players[i] = {};

          players[i].landmarks = {
            leftEye: scalePoints(landmarks.getLeftEye(), 3),
            rightEye: scalePoints(landmarks.getRightEye(), 3),
            mouth: scalePoints(landmarks.getMouthOuter(), 2),
            nose: scalePoints(landmarks.getNoseOuter(), 2, 1.5)
          };

          const pl = players[i].landmarks;

          var min = { x:Infinity, y:Infinity };
          var max = { x:0, y:0 };
          for (let point of pl.leftEye) {
            if (point.x < min.x) min.x = point.x;
            if (point.y < min.y) min.y = point.y;
            if (point.x > max.x) max.x = point.x;
            if (point.y > max.y) max.y = point.y;
          }
          var width = max.x - min.x;
          var height = max.y - min.y;

          players[i].eyeScale = width*height;

          // players[i].positions = {
          //   leftEye: centerOfPoints(pl.leftEye),
          //   rightEye: centerOfPoints(pl.rightEye),
          //   mouth: centerOfPoints(pl.mouth),
          //   nose: landmarks.getNosePoint(),
          // };

          players[i].graceTimer = 0;
        }
      }

      setTimeout(updateLandmarks);
    }

    function draw() {
      requestAnimationFrame(draw);

      context.reset();
      context.scale(window.devicePixelRatio, window.devicePixelRatio);

      context.fillStyle = "black";
      context.fillRect(0, 0, canvas.width, canvas.height);

      context.strokeStyle = "white";
      context.fillStyle = "white";

      for (let x=Math.min(players.length, positions.length)-1; x>=0; x--) {
        const player = players[x];
        for (let feature in player.landmarks) {
          const point = positions[x][feature];
          pasteFromVideo(player.landmarks[feature], point.x, point.y);
        }

        player.graceTimer++;
        if (player.graceTimer > 100) {
          players.splice(x, 1);
        }
      }
    }

    function pasteFromVideo(points, x, y) {
      var measurements = pointsSize(points);
      const min = measurements.min;
      const width = measurements.width;
      const height = measurements.height;

      testcanvas.width = width;
      testcanvas.height = height;
      testcontext.reset();
      testcontext.clearRect(0, 0, width, height);

      testcontext.beginPath();
      var last = points[points.length-1];
      testcontext.moveTo(last.x - min.x, last.y - min.y);
      for (let point of points) {
        testcontext.lineTo(point.x - min.x, point.y - min.y);
      }
      testcontext.clip();

      testcontext.drawImage(video, min.x, min.y, width, height, 0, 0, width, height);

      context.drawImage(testcanvas, x - width/2, y - height/2);
      var translatedPoints = [];
      for (let point of points) {
        translatedPoints.push({
          x: point.x - min.x + x - width/2,
          y: point.y - min.y + y - height/2,
        })
      }
      drawContour(context, translatedPoints, true);
    }
  </script>

</html>
